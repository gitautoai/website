import { test, expect } from "@playwright/test";
import { supabaseAdmin } from "@/lib/supabase/server";
import fs from "fs/promises";
import path from "path";
import { createTestOwner, cleanupTestOwner } from "../helpers/create-test-owner";
import { triggerStripeWebhook } from "../helpers/stripe-trigger";

test.describe("Manual Credit Purchase", () => {
  // Use auth state for regular user with credits
  test.use({ storageState: "e2e/.auth/regular-with-credits.json" });

  let testUserId: number;
  let testOwnerId: number;
  let installationId: number;

  test.beforeAll(async () => {
    // Read the test IDs generated by auth setup
    const testIdsPath = path.join(process.cwd(), "e2e", ".auth", "test-ids.json");
    const testIds = JSON.parse(await fs.readFile(testIdsPath, "utf-8"));
    const regularIds = testIds.regularWithCredits;

    testUserId = regularIds.userId;
    testOwnerId = regularIds.ownerId;
    installationId = regularIds.installationId;
  });

  test.beforeEach(async ({ page }) => {
    // Mock authentication API responses similar to legacy test
    await page.route("**/api/auth/session", (route) => {
      route.fulfill({
        contentType: "application/json",
        body: JSON.stringify({
          userId: testUserId,
          user: {
            id: testUserId.toString(),
            name: "Test Regular User",
            email: "regular@test.com",
            login: "regular-user",
            userId: testUserId,
          },
          jwtToken: "test-jwt-token",
          accessToken: "test-access-token",
        }),
      });
    });

    // Navigate to credits page
    await page.goto("/dashboard/credits");

    // Wait for page to load
    await expect(page.getByText("Credits Management")).toBeVisible();
  });

  test("should show success notification after successful payment", async ({ page }) => {
    // Simulate returning from Stripe with success parameter
    await page.goto("/dashboard/credits?success=true");

    // 1. Check for success toast notification
    await expect(
      page.getByText("ðŸŽ‰ Payment successful! Your credits have been added.")
    ).toBeVisible();

    // 2. Check for visual celebration effect (confetti canvas)
    const confettiCanvas = await page.locator("canvas");
    await expect(confettiCanvas).toBeVisible();

    // 3. Wait for celebration animation to complete
    await page.waitForTimeout(3000);
    await expect(confettiCanvas).not.toBeVisible();

    // 4. Check that URL parameters are removed
    await expect(page).toHaveURL("/dashboard/credits");
    expect(page.url()).not.toContain("success=true");
  });

  test("should show cancel notification after cancelled payment", async ({ page }) => {
    // Simulate returning from Stripe with cancel parameter
    await page.goto("/dashboard/credits?success=false");

    // Check for cancel toast notification
    await expect(page.getByText("Payment was cancelled. No charges were made.")).toBeVisible();

    // Check that URL parameters are removed
    await expect(page).toHaveURL("/dashboard/credits");
    expect(page.url()).not.toContain("success=false");
  });

  test("should update database after successful payment", async ({ page }) => {
    // Create test owner with initial credits
    const ownerResult = await createTestOwner({
      initialCredits: 50,
      ownerName: "test-manual-purchase-org",
    });

    expect(ownerResult.success).toBe(true);
    const testOwnerId = ownerResult.testOwnerId!;
    const testCustomerId = ownerResult.testCustomerId!;

    try {
      // Get initial credit balance from database
      const { data: initialOwner } = await supabaseAdmin
        .from("owners")
        .select("credit_balance_usd")
        .eq("owner_id", testOwnerId)
        .single();

      const initialBalance = initialOwner?.credit_balance_usd || 0;

      // Trigger Stripe webhook using CLI to simulate successful payment
      await triggerStripeWebhook({
        event: "payment_intent.succeeded",
        metadata: {
          owner_id: testOwnerId,
          credit_amount: 100,
          auto_reload: false,
        },
      });

      // Wait for webhook processing
      await page.waitForTimeout(2000);

      // Simulate successful payment page
      await page.goto("/dashboard/credits?success=true");

      // Wait for balance to update
      await page.waitForTimeout(2000);

      // Check database for updated balance
      const { data: updatedOwner } = await supabaseAdmin
        .from("owners")
        .select("credit_balance_usd")
        .eq("owner_id", testOwnerId)
        .single();

      const updatedBalance = updatedOwner?.credit_balance_usd || 0;
      expect(updatedBalance).toBeGreaterThan(initialBalance);

      // Check for new transaction in credits table
      const { data: recentTransaction } = await supabaseAdmin
        .from("credits")
        .select("*")
        .eq("owner_id", testOwnerId)
        .eq("transaction_type", "purchase")
        .order("created_at", { ascending: false })
        .limit(1)
        .single();

      expect(recentTransaction).toBeTruthy();
      expect(recentTransaction?.amount_usd).toBe(100);
    } finally {
      // Cleanup test data
      await cleanupTestOwner(testOwnerId, testCustomerId);
    }
  });

  test("should handle missing success parameter gracefully", async ({ page }) => {
    // Navigate without success parameter
    await page.goto("/dashboard/credits");

    // Should not show any notification
    await expect(page.getByText("Payment successful")).not.toBeVisible();
    await expect(page.getByText("Payment was cancelled")).not.toBeVisible();

    // Page should load normally
    await expect(page.getByText("Credits Management")).toBeVisible();
  });

  test("should persist notification across page refresh", async ({ page }) => {
    // Navigate with success parameter
    await page.goto("/dashboard/credits?success=true");

    // Check notification appears
    await expect(page.getByText("ðŸŽ‰ Payment successful!")).toBeVisible();

    // Verify URL has been cleaned
    await expect(page).toHaveURL("/dashboard/credits");

    // Refresh page
    await page.reload();

    // Notification should not reappear after refresh
    await expect(page.getByText("ðŸŽ‰ Payment successful!")).not.toBeVisible();
  });
});
