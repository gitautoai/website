import { test, expect } from "@playwright/test";
import fs from "fs/promises";
import path from "path";
import { supabaseAdmin } from "@/lib/supabase/server";
import { insertCredits } from "@/app/actions/supabase/credits/insert-credits";
import { cleanupTestOwner, createTestOwner } from "../helpers/create-test-owner";

// Helper function to call Vercel cron endpoints properly
const callVercelCronEndpoint = async (page: any, endpoint: string) => {
  const response = await page.request.get(endpoint, {
    headers: {
      "x-vercel-cron": "1",
      "user-agent": "vercel-cron/1.0",
    },
  });

  if (!response.ok()) {
    const errorText = await response.text();
    console.error(
      `Vercel cron endpoint ${endpoint} failed with status ${response.status()}: ${errorText}`
    );
  }

  return response;
};

test.describe("Auto-reload workflow", () => {
  // Use auth state for regular user with credits
  test.use({ storageState: "e2e/.auth/regular-with-credits.json" });

  let testUserId: number;
  let testOwnerId: number;
  let installationId: number;
  let testCustomerId: string;

  test.beforeAll(async () => {
    // Read the test IDs generated by auth setup
    const testIdsPath = path.join(process.cwd(), "e2e", ".auth", "test-ids.json");
    const testIds = JSON.parse(await fs.readFile(testIdsPath, "utf-8"));
    const regularIds = testIds.regularWithCredits;

    testUserId = regularIds.userId;
    installationId = regularIds.installationId;

    // Use the actual user ID as owner ID (for User type)
    testOwnerId = regularIds.userId; // For User type: owner_id = user_id

    // Get the test customer ID from the database
    const { data: owner } = await supabaseAdmin
      .from("owners")
      .select("stripe_customer_id")
      .eq("owner_id", testOwnerId)
      .single();

    testCustomerId = owner?.stripe_customer_id || `test-customer-${testOwnerId}`;
  });

  test.afterAll(async () => {
    // Don't cleanup - we're using shared test data from auth setup
  });

  test.beforeEach(async ({ page }) => {
    // Mock the NextAuth session endpoint to return authenticated session
    await page.route("**/api/auth/session", async (route) => {
      const sessionData = {
        user: {
          id: testUserId.toString(),
          name: "Test Regular User",
          email: "regular@test.com",
          login: "regular-user",
          userId: testUserId,
        },
        jwtToken: "test-jwt-token",
        accessToken: "test-access-token",
        expires: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // 24 hours from now
      };

      await route.fulfill({
        status: 200,
        contentType: "application/json",
        body: JSON.stringify(sessionData),
      });
    });

    // Set localStorage to ensure owner is selected
    await page.addInitScript(() => {
      localStorage.setItem("currentOwnerName", "regular-test-user");
    });
  });

  test.skip("should configure and trigger auto-reload", async ({ page }) => {
    // TODO: Fix organization dropdown not populating with "regular-test-user"
    // Root cause: Account context fetchInstallations returning empty installations array
    // This causes getInstalledRepos to return empty organizations, making dropdown show "Select Organization"
    // Previously worked with debug logging, suggests timing or data loading issue

    // Capture console logs
    page.on("console", (msg) => {
      if (msg.text().includes("[DEBUG")) console.log(`[BROWSER] ${msg.text()}`);
    });

    // Navigate to credits page
    await page.goto("/dashboard/credits");

    // Wait for the page to load and auto-reload settings to be visible
    await page.waitForSelector('[data-testid="auto-reload-settings"]');

    // Configure auto-reload settings
    await test.step("Configure auto-reload", async () => {
      const autoReloadSection = page.getByTestId("auto-reload-settings");

      // Wait for context to load - first wait for dropdown to be enabled
      const orgDropdown = page.locator("select").first();
      await expect(orgDropdown).toBeEnabled({ timeout: 10000 });

      // Then verify owner dropdown shows the selected user
      await expect(orgDropdown).toHaveValue("regular-test-user");

      // Wait for balance to be loaded
      await expect(page.getByTestId("credit-balance")).toHaveText("$100");

      // Now the context should be loaded, toggle should be enabled
      const toggleButton = autoReloadSection.getByRole("button").first(); // The toggle button
      await expect(toggleButton).toBeEnabled({ timeout: 10000 });
      await toggleButton.click();

      // Wait for state to update after toggle
      await page.waitForTimeout(500);

      // Set threshold to $10
      const thresholdInput = autoReloadSection.getByRole("spinbutton").first();
      await expect(thresholdInput).toBeEnabled();
      await thresholdInput.fill("10");

      // Set target to $50
      const targetInput = autoReloadSection.getByRole("spinbutton").nth(1);
      await expect(targetInput).toBeEnabled();
      await targetInput.fill("50");

      // Save settings
      await autoReloadSection.getByRole("button", { name: "Save Settings" }).click();

      // Wait for save to complete
      await page.waitForTimeout(1000);
    });

    // Simulate low balance by inserting negative credit record
    // IMPORTANT: Never manually update owners.credit_balance_usd directly!
    // Supabase has a trigger function that automatically recalculates balance:
    //
    // CREATE OR REPLACE FUNCTION update_owner_credit_balance() RETURNS TRIGGER AS $$
    // BEGIN
    //   UPDATE owners SET credit_balance_usd = (
    //     SELECT COALESCE(SUM(amount_usd), 0) FROM credits WHERE owner_id = target_owner_id
    //   ) WHERE owner_id = target_owner_id;
    //   RETURN NEW;
    // END; $$ LANGUAGE plpgsql;
    //
    // So to reduce balance, insert negative credit records to credits table
    await test.step("Deplete credits below threshold", async () => {
      // First check the balance before depletion
      const { data: beforeDepletion } = await supabaseAdmin
        .from("owners")
        .select("credit_balance_usd")
        .eq("owner_id", testOwnerId)
        .single();

      // Insert negative credit to simulate usage and bring balance to $5
      // Current: $100, Target: $5, so we need to subtract $95
      await insertCredits({
        owner_id: testOwnerId,
        amount_usd: -95, // Negative amount to reduce balance
        transaction_type: "usage",
        expires_at: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(),
      });

      // Verify the depletion worked (Supabase trigger will recalculate balance)
      const { data: afterDepletion } = await supabaseAdmin
        .from("owners")
        .select("credit_balance_usd")
        .eq("owner_id", testOwnerId)
        .single();
      expect(afterDepletion?.credit_balance_usd).toBe(5);
    });

    // Trigger auto-reload cron job
    await test.step("Trigger auto-reload check", async () => {
      const response = await callVercelCronEndpoint(page, "/api/cron/auto-reload");
      expect(response.ok()).toBeTruthy();

      const data = await response.json();
      expect(data.success).toBe(true);

      // Find our specific owner in the results
      const ourResult = data.results?.find((result: any) => result.ownerId === testOwnerId);

      // Verify our owner was processed successfully
      expect(ourResult).toBeDefined();
      expect(ourResult.success).toBe(true);
      expect(ourResult.amountCharged).toBe(45); // $50 target - $5 current = $45
      expect(ourResult.paymentIntentId).toBeDefined();

      // Wait for webhook to process and credits to be added
      // The webhook runs async after the Stripe charge completes
      await page.waitForTimeout(3000);

      // Check balance immediately after auto-reload
      const { data: afterAutoReload } = await supabaseAdmin
        .from("owners")
        .select("credit_balance_usd")
        .eq("owner_id", testOwnerId)
        .single();

      // Check what credit transactions exist using SQL
      const { data: transactions } = await supabaseAdmin
        .from("credits")
        .select("*")
        .eq("owner_id", testOwnerId)
        .order("created_at", { ascending: false });

      // Verify we now have 3 transactions: initial $100 + usage -$95 + auto-reload $45
      expect(transactions).toBeDefined();
      expect(transactions?.length).toBe(3);

      // Find the auto-reload transaction
      const autoReloadTransaction = transactions?.find((t) => t.transaction_type === "auto_reload");
      expect(autoReloadTransaction).toBeDefined();
      expect(autoReloadTransaction?.amount_usd).toBe(45);
      expect(autoReloadTransaction?.stripe_payment_intent_id).toBe(ourResult.paymentIntentId);

      // Also check the owners table balance directly
      const { data: ownerData } = await supabaseAdmin
        .from("owners")
        .select("credit_balance_usd")
        .eq("owner_id", testOwnerId)
        .single();

      // Balance should be $50 total ($100 initial - $95 usage + $45 auto-reload = $50)
      // The database trigger calculates balance as sum of all transactions
      expect(ownerData?.credit_balance_usd).toBe(50);
    });
  });

  test.skip("should not trigger auto-reload when disabled", async ({ page }) => {
    // TODO: Fix balance verification - expected $5 but got $100
    // Root cause: Credit depletion via insertCredits not properly reducing balance
    // Test creates owner with 100 credits, attempts to reduce to $5, but balance remains $100
    // Suggests Supabase trigger not recalculating balance or transaction not committing properly
    // Create a fresh test owner for this test to avoid interference
    const disabledTestOwner = await createTestOwner({
      initialCredits: 100,
      ownerName: "test-disabled-auto-reload",
      autoReloadEnabled: false, // Explicitly disable auto-reload
    });

    if (!disabledTestOwner.success) {
      throw new Error("Failed to create disabled test owner");
    }

    const disabledTestOwnerId = disabledTestOwner.testOwnerId!;
    const disabledTestCustomerId = disabledTestOwner.testCustomerId!;

    try {
      await page.goto("/dashboard/credits");

      // Wait for the page to load and auto-reload settings to be visible
      await page.waitForSelector('[data-testid="auto-reload-settings"]');

      // Ensure auto-reload is disabled (should already be disabled from createTestOwner)
      const autoReloadSection = page.getByTestId("auto-reload-settings");
      const toggleButton = autoReloadSection.getByRole("button").first();

      // Check if enabled and disable if needed
      const toggleClass = await toggleButton.getAttribute("class");
      const isEnabled = toggleClass?.includes("bg-pink-600");
      if (isEnabled) {
        await toggleButton.click();
      }

      // Deplete credits by inserting negative credit record
      // Note: Never update owners.credit_balance_usd directly - use insertCredits instead
      const { data: currentOwner } = await supabaseAdmin
        .from("owners")
        .select("credit_balance_usd")
        .eq("owner_id", disabledTestOwnerId)
        .single();

      const currentBalance = currentOwner?.credit_balance_usd || 0;
      const targetBalance = 5;
      const amountToSubtract = currentBalance - targetBalance;

      if (amountToSubtract > 0) {
        await insertCredits({
          owner_id: disabledTestOwnerId,
          amount_usd: -amountToSubtract,
          transaction_type: "usage",
          expires_at: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(),
        });
      }

      // Trigger cron job
      const response = await callVercelCronEndpoint(page, "/api/cron/auto-reload");
      expect(response.ok()).toBeTruthy();

      // Verify balance didn't change (should remain exactly $5)
      await page.waitForTimeout(1000);
      await page.reload();
      const balanceElement = page.getByTestId("credit-balance");
      await expect(balanceElement).toContainText("$5");
    } finally {
      // Cleanup
      await cleanupTestOwner(disabledTestOwnerId, disabledTestCustomerId);
    }
  });

  test("should respect auto-reload thresholds", async ({ page }) => {
    // Use the existing regular test user instead of creating a new one
    const thresholdTestOwnerId = testUserId;
    const thresholdTestCustomerId = testCustomerId;

    try {
      // Capture console logs
      page.on("console", (msg) => {
        if (msg.text().includes("[DEBUG")) console.log(`[BROWSER] ${msg.text()}`);
      });

      // Use the existing regular test user setup
      await page.addInitScript(() => {
        localStorage.setItem("currentOwnerName", "regular-test-user");
      });

      // No need for API mocking since we're using Server Actions now
      // The test data is already created in the database by createTestOwner

      await page.goto("/dashboard/credits");

      // Wait for the page to load and auto-reload settings to be visible
      await page.waitForSelector('[data-testid="auto-reload-settings"]');

      // Wait for data to be loaded - check if toggle button is enabled
      const autoReloadSection = page.getByTestId("auto-reload-settings");
      const toggleButton = autoReloadSection.getByRole("button").first();

      // Wait for toggle to be enabled (means data is loaded)
      await expect(toggleButton).toBeEnabled({ timeout: 10000 });

      // Check if inputs are already enabled (meaning auto-reload is already on)
      const thresholdInput = autoReloadSection.getByRole("spinbutton").first();

      // Get component state at the exact moment of isEnabled check
      const componentState = await autoReloadSection.evaluate((el) => ({
        loading: el.getAttribute("data-loading"),
        ownerId: el.getAttribute("data-owner-id"),
        enabled: el.getAttribute("data-enabled"),
      }));

      const isAlreadyEnabled = await thresholdInput.isEnabled();

      console.log(
        `[DEBUG] Component state: loading=${componentState.loading}, ownerId=${componentState.ownerId}, enabled=${componentState.enabled}`
      );
      console.log(`[DEBUG] Input isEnabled: ${isAlreadyEnabled}`);

      if (!isAlreadyEnabled) {
        console.log("[DEBUG] Toggle is disabled, attempting to click...");

        // Log toggle button state before click
        const toggleClass = await toggleButton.getAttribute("class");
        console.log(`[DEBUG] Toggle class before click: ${toggleClass}`);

        await toggleButton.click();
        console.log("[DEBUG] Toggle clicked");

        // Wait for inputs to become enabled
        await page.waitForTimeout(1000);

        // Check if click worked
        const toggleClassAfter = await toggleButton.getAttribute("class");
        const isEnabledAfter = await thresholdInput.isEnabled();
        console.log(`[DEBUG] Toggle class after click: ${toggleClassAfter}`);
        console.log(`[DEBUG] Input enabled after click: ${isEnabledAfter}`);

        if (!isEnabledAfter) {
          console.log("[DEBUG] Toggle click didn't work, taking screenshot...");
          await page.screenshot({ path: "debug-toggle-failed.png" });
        }
      }

      // Now configure the settings
      await expect(thresholdInput).toBeEnabled();
      await thresholdInput.fill("10");

      const targetInput = autoReloadSection.getByRole("spinbutton").nth(1);
      await expect(targetInput).toBeEnabled();
      await targetInput.fill("50");

      await autoReloadSection.getByRole("button", { name: "Save Settings" }).click();

      // Set balance to $15 (above threshold) by adjusting with credit records
      // Note: Never update owners.credit_balance_usd directly - use insertCredits instead
      const { data: currentOwner } = await supabaseAdmin
        .from("owners")
        .select("credit_balance_usd")
        .eq("owner_id", thresholdTestOwnerId)
        .single();

      const currentBalance = currentOwner?.credit_balance_usd || 0;

      const targetBalance = 15;
      const adjustment = targetBalance - currentBalance;

      if (adjustment !== 0) {
        await insertCredits({
          owner_id: thresholdTestOwnerId,
          amount_usd: adjustment,
          transaction_type: adjustment > 0 ? "purchase" : "usage",
          expires_at: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(),
        });

        // Verify the adjustment worked
        const { data: updatedOwner } = await supabaseAdmin
          .from("owners")
          .select("credit_balance_usd")
          .eq("owner_id", thresholdTestOwnerId)
          .single();
      }

      // Trigger cron job
      const response = await callVercelCronEndpoint(page, "/api/cron/auto-reload");
      expect(response.ok()).toBeTruthy();
      const data = await response.json();
      expect(data.success).toBe(true);

      // Check if our owner was processed
      const ourResult = data.results?.find(
        (result: any) => result.ownerId === thresholdTestOwnerId
      );

      // Verify balance didn't change (should remain exactly $15, above threshold)
      await page.waitForTimeout(1000);
      await page.reload();

      // Wait for the page to fully load with the correct owner data
      await page.waitForSelector('[data-testid="credit-balance"]');
      await page.waitForTimeout(500); // Additional wait for data to load

      const balanceElement = page.getByTestId("credit-balance");
      const finalBalance = await balanceElement.textContent();

      await expect(balanceElement).toContainText("$15");
    } finally {
      // No cleanup needed since we're using the shared test user
    }
  });
});
